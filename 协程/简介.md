# Go 语言中的协程（Goroutine）概述

## 简介

在 Go 语言中，**协程（Goroutine）** 是一种轻量级的并发执行机制。与传统线程相比，Goroutine 更加轻量，由 Go 运行时进行调度和管理。Goroutine 可以同时执行多个任务而不会消耗大量系统资源，这使得 Go 成为一个强大的并发编程语言。

Goroutine 严格来说不是传统意义上的**用户级线程（User-Level Thread, ULT）**，但它具有一些用户级线程的特点，同时也有独特之处，介于用户级线程和协程之间。以下是详细的分析：

## Goroutine 的特点

### 1. 用户级线程的特性

- **轻量级**：
  - 每个 Goroutine 的初始栈大小通常为 2KB，并且可以动态扩展。这使得在同一进程中可以创建数以百万计的 Goroutine。

- **用户态调度**：
  - Go 运行时自带一个调度器（M:N 模型），将多个 Goroutine 映射到少量的内核线程上运行。

- **非阻塞式设计**：
  - 当 Goroutine 遇到 I/O 阻塞或系统调用时，Go 的运行时可以动态分配其他线程，确保不会影响其他 Goroutine 的运行。

### 2. 与传统用户级线程的不同之处

- **更高的抽象**：
  - Goroutine 不直接暴露线程的概念，开发者无需管理上下文切换、同步等复杂性。

- **协作与抢占式调度**：
  - Go 的调度器支持一定程度的抢占式调度（如在垃圾回收时会暂停 Goroutine），但主要依赖协作式机制（通过 `runtime.Gosched()` 等显式挂起）。

- **异步阻塞处理**：
  - 传统用户级线程通常无法直接处理内核阻塞，阻塞会影响整个线程组。但 Goroutine 的运行时可以通过将阻塞任务交给其他线程来解决。

### 3. 与协程的相似性

- **协作调度**：
  - Goroutine 通过语言结构（如 `channel`、`select` 等）显式挂起和恢复，类似于协程的协作式调度。

- **轻量化设计**：
  - Goroutine 和协程都非常轻量，栈空间可以动态扩展，避免资源浪费。

---

## 协程的优势

与操作系统级别的线程相比，协程具有以下几个优势：

- **轻量级**：Goroutine 的栈空间是动态伸缩的，初始栈空间仅为几 KB，而不是操作系统线程的几 MB。
- **多任务并发**：Goroutine 允许同时执行多个任务，但每个 Goroutine 之间的开销非常小。
- **由 Go 运行时调度**：Go 语言的调度器可以在多个操作系统线程中分配和管理 Goroutine。

## 并发与并行

- **并发（Concurrency）**：多个任务可以在同一时间段交替执行，体现为任务之间快速切换，而并不是同时运行。
- **并行（Parallelism）**：多个任务真正同时执行，通常依赖于多个处理器或 CPU 核心的支持。

Go 的协程是并发编程的核心工具，可以用较少的系统资源处理大量并发任务。但要实现真正的并行，还需借助 Go 的多核支持。

## 协程的调度

Go 运行时内置了协程的调度器，称为 **GPM 模型**，其架构包括以下三部分：

- **G（Goroutine）**：代表协程，是通过 `go` 关键字启动的执行单元。
- **P（Processor）**：代表逻辑处理器，负责管理可执行的 G。Go 默认会根据 CPU 核心数创建等量的 P。
- **M（Machine）**：代表操作系统线程，实际执行任务的载体。

协程通过 P 分配到 M 上执行，而调度器会根据系统资源动态地调度协程。

![GPM 模型](/assets/img_1269386193.png)

## 传统的调度模型

传统的调度模型为**M:N 调度模型**，其中：

- **M** 是用户态线程的数量。
- **N** 是内核线程的数量。
  
![img.png](/assets/img_129639621389.png)

![M:N 调度模型](/assets/ult_klt_1_1.jpg)

---

### 对比总结

| **特性**     | **用户级线程（ULT）** | **Goroutine**           | **协程（Coroutines）** |
|------------|----------------|-------------------------|--------------------|
| **调度方式**   | 用户态调度，支持抢占式    | 用户态调度，主要协作式，支持部分抢占      | 完全协作式              |
| **阻塞操作影响** | 阻塞可能影响整个线程组    | 阻塞仅影响当前 Goroutine，运行时处理 | 阻塞仅影响当前协程          |
| **与内核交互**  | 映射到内核线程或独立运行   | 动态映射到内核线程               | 无需直接映射到内核线程        |
| **复杂性**    | 较高，需要手动管理      | 较低，Go 运行时自动管理           | 较低，由语言或框架支持        |

Goroutine 不能简单地定义为用户级线程或协程，而是结合了两者的优点：

1. **比用户级线程更轻量**，无须直接管理上下文切换。
2. **比协程更灵活**，具备运行时调度器支持抢占和阻塞处理的能力。

因此，Goroutine 是 Go 语言特有的一种高效并发原语，适合处理大量并发任务而无需手动处理复杂的线程管理或协程逻辑。

## 协程的常见问题

- **资源泄漏**：如果协程没有合适的退出条件，可能导致协程持续运行，消耗资源。
- **死锁**：不正确的 `channel` 使用或协程间通信可能导致程序陷入死锁。
- **数据竞争**：如果多个协程同时读写共享数据而没有进行同步，可能会出现数据竞争。Go 提供了 `go run -race` 命令，可以帮助检测程序中的数据竞争问题。

通过理解和掌握 Goroutine 的特性及其优势，开发者可以更有效地利用 Go 语言进行并发编程，构建高效、可扩展的应用程序。

